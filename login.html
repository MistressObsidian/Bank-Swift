<!-- Shared platform utilities: user session, transfers sync (API + SheetDB fallback) -->
<script>
(function (global) {
  const API_BASE = 'https://www.shenzhenswift.online'; // production only
  const SHEETDB_API_URL = 'https://sheetdb.io/api/v1/3g36t35kn6po0';
  const SHEETDB_API_TOKEN = 'bdqkosnudoi2kv7ilujkh192vndz3osnqkvh2mw3';

  global.API_BASE = API_BASE;
  global.SHEETDB_API_URL = SHEETDB_API_URL;
  global.SHEETDB_API_TOKEN = SHEETDB_API_TOKEN;

  function sheetAuthHeaders(extra = {}) {
    return Object.assign({ 'Authorization': `Bearer ${SHEETDB_API_TOKEN}` }, extra);
  }

  async function sheetSearch(params) {
    const qs = new URLSearchParams(params).toString();
    const url = `${SHEETDB_API_URL}/search?${qs}&casesensitive=false`;
    const res = await fetch(url, { headers: sheetAuthHeaders() });
    if (!res.ok) return [];
    return res.json();
  }

  async function sheetInsert(rows) {
    if (!Array.isArray(rows) || !rows.length) return false;
    try {
      const res = await fetch(SHEETDB_API_URL, {
        method: 'POST',
        headers: sheetAuthHeaders({ 'Content-Type': 'application/json' }),
        body: JSON.stringify({ data: rows })
      });
      return res.ok;
    } catch { return false; }
  }

  async function sheetPatch(reference, fields) {
    try {
      const payload = { data: [{ reference, ...fields }] };
      const res = await fetch(SHEETDB_API_URL, {
        method: 'PATCH',
        headers: sheetAuthHeaders({ 'Content-Type': 'application/json' }),
        body: JSON.stringify(payload)
      });
      if (res.ok) return true;
    } catch {}
    return sheetInsert([{ formType: 'Transfer', reference, ...fields }]);
  }

  function getUser() {
    try { return JSON.parse(sessionStorage.getItem('loggedInUser') || ''); } catch { return null; }
  }

  function shapeRow(t) {
    return {
      formType: 'Transfer',
      reference: t.reference,
      email: t.email || (getUser() && getUser().email) || '',
      amount: t.amount,
      from: t.from || t.from_account || '',
      to: t.to || t.to_account || '',
      status: t.status || 'Pending',
      dateISO: t.dateISO || new Date().toISOString(),
      network: t.type || t.network || 'Transfer'
    };
  }

  async function recordTransferToSheet(t) {
    try {
      if (!t || !t.reference) return;
      const existing = await sheetSearch({ formType: 'Transfer', reference: t.reference });
      if (Array.isArray(existing) && existing.length) {
        const row = existing[0];
        if (row.status !== t.status) await sheetPatch(t.reference, { status: t.status });
        return;
      }
      return sheetInsert([shapeRow(t)]);
    } catch {}
  }
})(window);
</script>
  <!-- Fixed header -->
  <header>
    <div class="container">
      <nav>
        <div class="logo">Shenzhenswift</div>        <ul class="nav-links">          <li><a href="dashboard.html">Home</a></li>          <li><a href="transfer.html">Transfer</a></li>          <li><a href="#">Cards</a></li>          <li><a href="#">Support</a></li>        </ul>      </nav>    </div>  </header>  <!-- Main content -->  <main>    <div class="container">      <div class="page-header">        <div>          <div class="page-title">Transaction details</div>          <div class="subtitle">Confirmation and breakdown of your recent transaction</div>        </div>      </div>      <section class="card confirm" id="txContainer">        <div class="success-banner">          <div class="success-icon">✓</div>          <div id="bannerText">Processing...</div>        </div>        <div class="amount-line">          <div class="value" id="amountValue">$0.00</div>          <div class="muted" id="summaryText">—</div>        </div>        <div class="details-grid">          <div class="detail">            <div class="label">Status</div>            <div class="value"><span class="status-pill" id="statusPill">Pending</span></div>          </div>          <div class="detail">            <div class="label">Date & time</div>            <div class="value" id="dateTimeValue">—</div>          </div>          <div class="detail">            <div class="label">From account</div>            <div class="value" id="fromValue">—</div>          </div>          <div class="detail">            <div class="label">To account</div>            <div class="value" id="toValue">—</div>          </div>          <div class="detail">            <div class="label">Reference / ID</div>            <div class="value" id="referenceValue">—</div>          </div>          <div class="detail">            <div class="label">Network / Type</div>            <div class="value" id="networkValue">—</div>          </div>          <div class="detail">            <div class="label">Fees</div>            <div class="value" id="feesValue">—</div>          </div>          <div class="detail">            <div class="label">Posted by</div>            <div class="value" id="postedByValue">Shenzhenswift Processing</div>          </div>        </div>        <div class="actions">          <button class="btn btn-outline" onclick="window.print()">Download receipt</button>          <a class="btn btn-primary" href="transfer.html">Make another transfer</a>          <a class="btn btn-outline" href="dashboard.html">Back to dashboard</a>        </div>        <div class="note">Transfers between your Shenzhenswift accounts usually post instantly. External transfers may take 1–3 business days.</div>      </section>      <div style="height:24px;"></div>    </div>  </main>  <script>    // Build the page from only the current transaction:    // - If ?ref=<id> present, show that tx    // - Else show the most recent initiated transaction for the logged-in user    (function(){      const user = safeParse(sessionStorage.getItem('loggedInUser')) || {};      let list = safeParse(sessionStorage.getItem('initiatedTransactions')) || [];      // Keep only this user's transactions if email is stored      if (user.email) {        list = list.filter(t => !t.email || t.email === user.email);      }      const params = new URLSearchParams(location.search);      const ref = params.get('ref') || params.get('id') || params.get('reference');  let tx = null;      if (ref) {        tx = list.find(t => (t.reference || t.ref || t.id) === ref) || null;      }      if (!tx) {        // Use the most recent one (assuming you unshift on creation)        tx = list[0] || null;      }      if (!tx) {        // Nothing to show — replace card with empty state        const container = document.getElementById('txContainer');        container.innerHTML = `          <div class="amount-line">            <div class="value">$0.00</div>            <div class="muted">No current transaction to display</div>          </div>          <div class="actions" style="margin-top:8px;">            <a class="btn btn-primary" href="transfer.html">Make a transfer</a>            <a class="btn btn-outline" href="dashboard.html">Back to dashboard</a>          </div>        `;        return;      }      // Helpers      function safeParse(s){ try { return JSON.parse(s||''); } catch { return null; } }      function fmtAmount(a, delta){        if (!a && delta) return delta; // e.g., "- $2,000.00"        if (typeof a === 'string') return a;        if (typeof a === 'number') return a.toLocaleString(undefined, { style:'currency', currency: (tx.currency||'USD') });        return '$0.00';      }      function nowISOToLocal(iso){        try{          const d = iso ? new Date(iso) : new Date();          return `${d.toLocaleDateString()} • ${d.toLocaleTimeString()}`;             document.getElementById('amountValue').textContent = fmtAmount(tx.amount, tx.delta);      const fromText = tx.from || tx.fromAccount || '—';      const toText = tx.to || tx.toAccount || '—';      const actionWord = (tx.type && /deposit|credit/i.test(tx.type)) ? 'to' : 'to';      document.getElementById('summaryText').textContent =        (fromText !== '—' || toText !== '—')          ? `Transferred from ${fromText} ${actionWord} ${toText}`          : (tx.name || tx.type || 'Transfer');      document.getElementById('statusPill').textContent = status;      document.getElementById('dateTimeValue').textContent = tx.dateTime || nowISOToLocal(tx.dateISO || tx.date);      document.getElementById('fromValue').textContent = fromText;      document.getElementById('toValue').textContent = toText;      document.getElementById('referenceValue').textContent = tx.reference || tx.ref || tx.id || '—';      document.getElementById('networkValue').textContent = tx.network || tx.type || 'Transfer';      document.getElementById('feesValue').textContent = tx.fees || tx.fee || '—';      document.getElementById('postedByValue').textContent = tx.postedBy || 'Shenzhenswift Processing';      // Fetch from API for true source of truth      const token = localStorage.getItem('api_token') || '';      if (tx.reference || ref) {        // Primary: API        if(token){          fetch(`http://localhost:3001/api/transfers?ref=${encodeURIComponent(tx.reference || ref)}`, { headers:{ Authorization:`Bearer ${token}` } })            .then(r => r.ok ? r.json() : []).then(arr => {              if (Array.isArray(arr) && arr[0]) {                const t = arr[0];                const s = t.status || 'Pending';                document.getElementById('statusPill').textContent = s;                document.getElementById('bannerText').textContent = (s.toLowerCase()==='pending') ? 'Processing' : 'Completed';                document.getElementById('dateTimeValue').textContent = nowISOToLocal(t.updatedAt || t.dateISO);                document.getElementById('fromValue').textContent = t.from || tx.from || '—';                document.getElementById('toValue').textContent = t.to || tx.to || '—';              } else if (window.Platform && Platform.fetchTransferByRef) {                // Fallback to Sheet                Platform.fetchTransferByRef(tx.reference || ref).then(t => { if(!t) return; const s=t.status||'Pending'; document.getElementById('statusPill').textContent=s; document.getElementById('bannerText').textContent=(s.toLowerCase()==='pending')?'Processing':'Completed'; });              }            }).catch(()=>{ if(window.Platform && Platform.fetchTransferByRef){ Platform.fetchTransferByRef(tx.reference || ref).then(t => { if(!t) return; const s=t.status||'Pending'; document.getElementById('statusPill').textContent=s; document.getElementById('bannerText').textContent=(s.toLowerCase()==='pending')?'Processing':'Completed'; }); } });        } else if (window.Platform && Platform.fetchTransferByRef){          Platform.fetchTransferByRef(tx.reference || ref).then(t => { if(!t) return; const s=t.status||'Pending'; document.getElementById('statusPill').textContent=s; document.getElementById('bannerText').textContent=(s.toLowerCase()==='pending')?'Processing':'Completed'; });        }        // Subscribe to SSE for live changes        try {          const src = new EventSource(`http://localhost:3001/api/stream?token=${encodeURIComponent(token)}`);      const onUpdate = (ev) => {            try{              const data = JSON.parse(ev.data||'{}');              if (data.reference === (tx.reference || ref)) {                const s = data.status || 'Pending';                document.getElementById('statusPill').textContent = s;                document.getElementById('bannerText').textContent = (s.toLowerCase()==='pending') ? 'Processing' : 'Completed';                if (data.updatedAt) document.getElementById('dateTimeValue').textContent = nowISOToLocal(data.updatedAt);              }        if(window.Platform && Platform.applyTransferEvent) Platform.applyTransferEvent(data);            }catch{}          };          src.addEventListener('transfer.updated', onUpdate);          window.addEventListener('beforeunload', () => { try{ src.close(); }catch{} });        } catch {}      }    })();  </script>  <script src="common.js"></script>  <script>
  // ...existing code (fill, load) ...
  try {
    if (ref) {
      // Production SSE stream; ensure server supports CORS + EventSource at this URL
      const src = new EventSource(`${API_BASE}/api/stream?ref=${encodeURIComponent(ref)}`);
      src.addEventListener('transfer.updated', ev => {
        try {
          const d = JSON.parse(ev.data || '{}');
          if (d.reference === ref) fill(d);
        } catch {}
      });
      window.addEventListener('beforeunload', () => { try { src.close(); } catch {} });
    }
  } catch {}
  </script>
</body>
</html>
